Task 2. Containers
=
2.1. [Динамический_массив](#Динамический_массив)\
2.2. [Связный_список](#Связный_список)

Реализации абстрактных типов данных,
хранящие данные и предоставляющие к ним доступ.\
Эти контейнеры обеспечивают управление памятью, необходимую для хранения данных,
и представляют интерфейсы для доступа к хранимым данным.

2.1. Динамический массив
---
<a name="Динамический массив"></a> 

Абстрактный тип данных \<T> class Array final лежит в файле include/dynamic_array/dynamic_array.hpp

---
Шаблон

template <typename T>\
class Array final

должен поддерживать следующие операции:
1. Array();\
Array(int _capacity);\
\
Конструктор распределяет память, необходимую для хранения некоторого
количества элементов. Конструктор без параметров использует значение
емкости по умолчанию (например, 8 или 16), конструктор с параметром
_capacity – явно переданное значение.

2. ~Array();\
\
Деструктор освобождает память, выделенную под хранение элементов. При
необходимости, при освобождении памяти вызываются деструкторы
хранимых элементов.

3. void insert(const T& value);\
void insert(int index, const T& value);\
\
Вставляет переданное значение в конец массива, или в указанную позицию,
увеличивая размер массива на 1 и, при необходимости, сдвигая
существующие элементы вправо. Если памяти для добавления элемента
недостаточно, то перераспределяет память, копируя уже существующие
элементы в новую область. Затем старый блок освобождается. Для
копирования и сдвигания элементов желательно использовать
move-семантику. (Также можно использовать устаревшее и менее
эффективное копирование с последующим вызовом деструктора).
Выделение памяти происходит каждый раз с увеличением в 1.6..2 раза
относительно текущего размера.

4. void remove( int index);\
\
Удаляет элемент из указанной позиции массива, сдвигая остальные
элементы влево (сдвиги выполняются аналогично insert(),
но память при этом не освобождается).

5. const T& operator \[](int index) const;\
T& operator \[](int index);\
\
Оператор индексирования позволяет обратиться к элементу массива по
индексу для чтения и для записи.

6. int size() const;\
\
Возвращает текущий размер (количество реально существующих в массиве) элементов.

7. Iterator iterator();\
const Iterator iterator() const;\
\
Возвращает итератор, указывающий на первый элемент массива.
Обратите внимание, что по правилам C++ такой массив может копироваться и
присваиваться, однако поведение копирования и присваивания по умолчанию
приведет к проблемам, связанным с тем, что оба экземпляра будут использовать
один и тот же блок памяти, и пытаться освобождать его в деструкторе. Поэтому
вы должны или предоставить правильный механизм копирования и присваивания
или запретить его.
Итератор должен быть реализован как внутренний для Array<T> класс, и
предоставлять следующий интерфейс:

1.) const T& get() const;\
\
Получает значение массива в текущей позиции итератора.

2.) void set(const T& value);\
\
Устанавливает значение в текущей позиции итератора.

3.) void insert(const T& value);\
\
Вставляет значение в текущую позицию итератора, сдвигая
соответствующие элементы (начиная с текущего) вправо. Итератор после
вставки остается позиционированным на новый элемент.

4.) void remove();\
\
Удаляет значение из текущей позиции итератора, сдвигая соответствующие
элементы (начиная с элементом, следующего за текущим) влево. Итератор
после удаления остается позиционированным на элемент, оказавшийся на
позиции удаленного.

5.) void next();\
\
Перемещает текущую позицию итератора на 1 вправо, переходя к
следующему элементу.

6.) void prev();\
\
Перемещает текущую позицию итератора на 1 влево, переходя к
предыдущему элементу.

7.) void toIndex(int index);\
\
Устанавливает позицию итератора на элемент с указанным индексом.

8.) bool hasNext() const;\
\
Возвращает true , если итератор может перейти к следующему элементу,
или false , если итератор позиционирован на последний элемент.

9.) bool hasPrev() const;\
\
Возвращает true , если итератор может перейти к предыдущему элементу,
или false , если итератор позиционирован на первый элемент.\
Функции работы с индексом не должны выполнять проверку границ. Но в
отладочной версии такие проверки можно добавить используя механизм
утверждений.

Пример использования:
поместим в массив числа от 1 до 10, умножим каждое на 2,
затем выведем их на экран.

Array<int> a;\
for (int i = 0; i < 10; ++i)\
a.insert(i + 1);\
for (int i = 0; i < a.size(); ++i)\
a[i] *= 2;\
for (auto it = a.iterator(); it.hasNext(); it.next())\
std::cout << it.get() << std::endl;\

---
§2: Связный список
---
<a name="Связный_список"></a> 

Абстрактный тип данных template <typename T> class List final лежит
в файле include/linked_list/linked_list.hpp.

---
Шаблон

template <typename T>\
class List final

должен реализовывать двусвязный список с чанками
и поддерживать следующие операции:

1. List();\
\
Конструктор распределяет память, необходимую для хранения одного
чанка списка.

2. ~List();\
\
Деструктор освобождает память, выделенную под хранение элементов. При
необходимости, при освобождении памяти вызываются деструкторы
хранимых элементов.

3. void insertHead(const T& value);\
void insertTail(const T& value);\
\
Вставляет переданное значение в голову или хвост списка, помещая
значение в соответствующий чанк. При необходимости, выделяется новый
чанк и добавляется к списку в начало или конец.

4. void removeHead();\
void removeTail();\
\
Удаляет элемент из головы / хвоста списка, при необходимости удаляя
освободившиеся чанки (за исключением последнего, который должен
присутствовать даже для пустого списка).

5. const T& head() const;\
const T& tail() const;\
\
Возвращает текущее значение находящееся в голове / хвосте списка.

6. int size() const;\
\
Возвращает текущий размер (количество реально существующих в списке)
элементов. Это значение лучше хранить в поле объекта List , изменять при
вставке удалении и не пересчитывать каждый раз.

7. Iterator iterator();\
const Iterator iterator() const;\
\
Возвращает итератор, указывающий на первый элемент списка.

Размер чанка подберите самостоятельно. В комментариях поясните, почему
выбрали именно такой размер.\
Для списка справедливы те же рассуждения о присваивании и копировании, что и
для массива.\
Итератор должен быть реализован как внутренний для List<T> класс, и
предоставлять интерфейс, аналогичный Array<T>::Iterator , за исключением
toIndex(), так как список не подразумевает произвольного доступа.
Для всех реализованных методов динамического массива и списка должны быть
созданы необходимые модульные тесты.